━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━(DB-schema)━━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
books       movies
-----       ------
id          id
name        name
author      author
year        year
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
A)━━━━━━━━━━━━━━━━━━(Select * FROM * WHERE * = *)━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
##schema: iterate tables and combine##

SELECT * FROM tbl_list as t
for [i | argv_tables > 0] in t
  SELECT * FROM i.field_list as f
  fields = [v | argv_fields > 0]
    SELECT fields FROM t
    [ | argv_crtieria > 0 ]
    WHERE fields[...] = argv_criteria

##sql_concat##
sql_concat [columns] [filters] [oper]

if [ ${#1} -ne ${#2} ]
  error
else
  column=$(echo $1 | tr "," " ")
  filter=$(echo $2 | tr "," " ")
  count=0
  for s in $column
    sql+=" $s = ${filter[$count]}"
    ((count++))
  done
fi
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#no filters
tbl_list = table_data
for table in tbl_list
  select * from table
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#columns but no filter
tbl_list = table_data
for table in tbl_list
  field_list = field_data table
  select field_list from table
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#columns and filter
tbl_list = table_data
for table in tbl_list
  sql_concat column_list filters
  select field_list from table where filters
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#filter but no columns
tbl_lsit = table_data
for table in tbl_list
  field_list = field_data table
  sql_concat field_list filters
  select field_list from table where filters
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
##Dependencies:##
D-1) sqlite fetch list of existing tables as
tbl_list.
D-2) sqlite fetch list of existing field names
per table as field_list.

##Problems:##
P-1) supplied field names that don't exist in
one table but do in another.
S-1) always query for list of tables/ fields and
check against the list for existence to avoid
sqlite returning errors.

P-2) poor scalability because checking
for all tables -> for all fields.
S-2) there are existence checks that avoid this problem.
the only overhead is querying every table (less if specified)
for its name and fields. the remaining logic is the same
as a regualr query.

P-3) no associations made in getopts for
  table1 -> field1, table2 -> field2.
instead, it presents as:
for all tables unless specified AS t
  field1 (if exists in t), field2 (if exists in t).

P-4) behavior of filters is awkward.
-c id name -v 2 3
where id = 2 and name = 3
or
where id = 2 and 3 or name = 2 and 3
-v 2 3
where [each field] = 2 and 3
-f id name -v 2 3
where id = 2 and name = 3
-c id -f name -v 3
where name = 3
S-4) behavior as so:
column|filter|value||id = 2 and name = 3
column|no filter|value||id = 2 || 3 or name = 2 || 3
filter option uses exact order of filters to values
no filter option uses supplied columns to all values
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━(Nested options)━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
eii -s -t books -c name year -f name -v "unix systems"

while $# do
case $1
-s) read_s_args ${@}      | -t books
-t) read_s_args ${@}      | -c name year
-f) read_s_args ${@}      | -f name
-v) read_s_args ${@}      | -v "unix systems"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
B)━━━━━━━━━━━━━━━(DELETE * FROM * WHERE * = *)━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#do a select then prompt for confirmation to delete records
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
C)━━━━━━━━━━━━━━━(UPDATE * WHERE * = *)━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SELECT _name_ FROM _table_ |
  [ {WHERE _filter_ = _value_} ... ]
UPDATE [table] SET [name] = [value] WHERE = [filter] = [val2]
eii -u -t book -c id -f 
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
D)━━━━━━━━━━━━━━━(INSERT * INTO *)━━━━━━━━━━━━━━━━━━━━━━━━━━
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
INSERT INTO _table_ {_value_} ...

##Problems:##
P-1) too many or too few supplied fields for a given table.
S-1) run only if table name count == value count.
P-2) duplicates.
S-3) 
P-3) adding to multiple tables at once instead of a specific
table.
S-3) show list of tables being inserted into and prompt for
confirmation.
